<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>crypto on Franziskus Kiefer</title>
    <link>https://www.franziskuskiefer.de/tags/crypto/</link>
    <description>Recent content in crypto on Franziskus Kiefer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.franziskuskiefer.de/tags/crypto/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Shared-Secrets Service</title>
      <link>https://www.franziskuskiefer.de/post/shared-secrets-service/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/shared-secrets-service/</guid>
      <description>At the Berlin Crypto this month we had a talk by Kevin about a shared-secret service they developed at Syselevn. After experimenting with PGP and deciding that it doesn&amp;rsquo;t do what they needed, they decided to go with a very simple, custom encrypt-then-mac scheme. You can find details here. When someone says they built their own encryption scheme and message format I get obviously curious. In this post I want to summarize the scheme, design decisions, compare it standard authenticated encryption schemes, and ponder the question of the right security definitions.</description>
    </item>
    
    <item>
      <title>Wrapping arithmetic in Rust</title>
      <link>https://www.franziskuskiefer.de/post/wrapping-arithmetic/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/wrapping-arithmetic/</guid>
      <description>One of Rusts great feature is that it catches integer overflows at runtime and panics rather than wraps (in debug builds). I recommend you read Huon&amp;rsquo;s blog post about this from a couple years ago.
While this is a desirable behaviour in general, integer overflows are commonly used when implementing cryptography primitives. Rust offers wrapping alternatives such as wrapping_add etc. to allow wrapping behaviour. However, this makes code very hard to read, e.</description>
    </item>
    
    <item>
      <title>Update on hacspec</title>
      <link>https://www.franziskuskiefer.de/post/hacspec2/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacspec2/</guid>
      <description>Earlier this year I introduced hacspec, a new specification language for cryptographic primitives. After Karthik presented the idea and very preliminary results at IETF 101 in March we made quite some progress and presented a paper with a little more detail at SSR earlier this week. In this blog post I&amp;rsquo;ll give the gist of the SSR paper and introduce the first version of hacspec.
All information about hacspec can be found at https://hacs-workshop.</description>
    </item>
    
    <item>
      <title>The HACL* approach</title>
      <link>https://www.franziskuskiefer.de/post/hacl-star/</link>
      <pubDate>Wed, 14 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacl-star/</guid>
      <description>HACL* (High-Assurance Cryptographic Library) is a formally verified cryptographic library in F*, developed by the Prosecco team at INRIA Paris in collaboration with Microsoft Research, as part of Project Everest. HACL* was inspired by discussions at the HACS workshop and aims at developing a set of reference implementations in C for common cryptographic primitives.
This is the first post in a series describing formal verification in NSS as an approach to improve confidence in highly complex, highly security critical code.</description>
    </item>
    
    <item>
      <title>Introducing HacSpec</title>
      <link>https://www.franziskuskiefer.de/post/hacspec1/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacspec1/</guid>
      <description>HacSpec is a proposal for a new specification language for cryptographic primitives that is succinct, that is easy to read and implement, and that lends itself to formal verification. It aims to formalise the pseudocode used in cryptographic standards by proposing a formal syntax that can be checked for simple errors. HacSpec specifications are further executable to test against test vectors specified in a common syntax.
The main focus of HacSpec is to allow specifications to be compiled to formal languages such as cryptol, coq, F*, and easycrypt and thus make it easier to formally verify implementations.</description>
    </item>
    
    <item>
      <title>CVE-2017-5462 - A PRNG issue</title>
      <link>https://www.franziskuskiefer.de/post/cve-2017-5462/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/cve-2017-5462/</guid>
      <description>On April 19, 2017, Mozilla Foundation published the Security Advisory 2017-10 outlining several recently fixed security vulnerabilities. One of these vulnerabilities, tracked as CVE-2017-5462, affects the Pseudo-Random Number Generator (PRNG) within the Network Security Services (NSS) library prior to version 3.29.5 and Firefox prior to version 53.
This post describes the bug and how it was discovered.
Inside the NSS PRNG NSS uses Hash_DRBG as PRNG, which is one of several PRNG schemes defined in the NIST Special Publication 800-90.</description>
    </item>
    
    <item>
      <title>Aes Gcm Speedup</title>
      <link>https://www.franziskuskiefer.de/post/aes-gcm-speedup/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/aes-gcm-speedup/</guid>
      <description>AES-GCM is a NIST standardised authenticated encryption algorithm (FIPS 800-38D). Since its standardisation in 2008 its usage increased to a point where it is the prevalent encryption used with TLS. With 85% it is by far the most widely used cipher.
 Firefox 53 TLS cipher telemetry   Unfortunately the AES-GCM implementation used in Firefox (provided by NSS) does not take advantage of full hardware acceleration; it uses a slower software-only implementation on Mac, Linux 32-bit, or any device that doesn&amp;rsquo;t have the AVX, PCLMUL, and AES-NI hardware instructions.</description>
    </item>
    
    <item>
      <title>On Constant Time Division</title>
      <link>https://www.franziskuskiefer.de/post/constant-time-division/</link>
      <pubDate>Wed, 28 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/constant-time-division/</guid>
      <description>Writing constant time code is hard. We all know that. But I&amp;rsquo;m always amazed again on how difficult it is. In preparation for making NSS more constant time I looked into certain CPU instructions that are known to be not constant time. So I wrote a little thing to measure the time (CPU cycles) needed for division.
div rcx ; eax is now a/b The CPU I&amp;rsquo;m using in this post is an Intel i7-4790 (haswell).</description>
    </item>
    
  </channel>
</rss>
