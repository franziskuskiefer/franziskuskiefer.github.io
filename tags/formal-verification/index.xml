<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Formal Verification on Dr Franziskus Kiefer</title><link>https://www.franziskuskiefer.de/tags/formal-verification/</link><description>Recent content in Formal Verification on Dr Franziskus Kiefer</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 21 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.franziskuskiefer.de/tags/formal-verification/index.xml" rel="self" type="application/rss+xml"/><item><title>Wrapping arithmetic in Rust</title><link>https://www.franziskuskiefer.de/p/wrapping-arithmetic-in-rust/</link><pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.franziskuskiefer.de/p/wrapping-arithmetic-in-rust/</guid><description>&lt;p>One of Rusts great feature is that it catches integer overflows at runtime and panics rather than wraps (in debug builds).
I recommend you read &lt;a class="link" href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/" target="_blank" rel="noopener"
>Huon&amp;rsquo;s blog post&lt;/a> about this from a couple years ago.&lt;/p>
&lt;p>While this is a desirable behaviour in general, integer overflows are commonly used when implementing cryptography primitives.
Rust offers wrapping alternatives such as &lt;code>wrapping_add&lt;/code> etc. to allow wrapping behaviour.
However, this makes code very hard to read, e.g. &lt;code>let c = a + b&lt;/code> is easier to read than &lt;code>let c = a.wrapping_add(b)&lt;/code>.&lt;/p>
&lt;h2 id="other-wrapping-arithmetic">Other wrapping arithmetic
&lt;/h2>&lt;p>Rust itself provides a wrapping integer type in &lt;a class="link" href="https://doc.rust-lang.org/std/num/struct.Wrapping.html" target="_blank" rel="noopener"
>&lt;code>std::num::Wrapping&lt;/code>&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="n">num&lt;/span>::&lt;span class="n">Wrapping&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">zero&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Wrapping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="k">u32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">one&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Wrapping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="k">u32&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="fm">assert_eq!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="kt">u32&lt;/span>::&lt;span class="no">MAX&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">zero&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">one&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is a good solution when you want to be explicit about what you&amp;rsquo;re doing.
However, its readability is still not great.&lt;/p>
&lt;h2 id="wrappit">#[wrappit]
&lt;/h2>&lt;p>To alleviate this shortcoming I implemented a &lt;a class="link" href="https://doc.rust-lang.org/reference/procedural-macros.html" target="_blank" rel="noopener"
>procedural macro&lt;/a> that rewrites arithmetic operators &lt;code>+,-,*&lt;/code> into their wrapping equivalents &lt;code>wrapping_add, wrapping_sub, wrapping_mul&lt;/code> as well as their assigning versions &lt;code>+=,-=,*=&lt;/code>.&lt;/p>
&lt;p>The following function for example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#[wrappit]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">mix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>: &lt;span class="kt">u32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>: &lt;span class="kt">u32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">u32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>is rewritten to&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Rust" data-lang="Rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">mix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>: &lt;span class="kt">u32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>: &lt;span class="kt">u32&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">u32&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="kt">u32&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wrapping_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wrapping_mul&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can find wrapping_arithmetic on &lt;a class="link" href="https://github.com/franziskuskiefer/wrapping-arithmetic" target="_blank" rel="noopener"
>GitHub&lt;/a> and on &lt;a class="link" href="https://crates.io/crates/wrapping_arithmetic" target="_blank" rel="noopener"
>crates.io&lt;/a>.
To use &lt;code>#[wrappit]&lt;/code> add &lt;code>wrapping_arithmetic = &amp;quot;0.1&amp;quot;&lt;/code> to your &lt;code>cargo.toml&lt;/code>.&lt;/p></description></item><item><title>Update on hacspec</title><link>https://www.franziskuskiefer.de/p/update-on-hacspec/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.franziskuskiefer.de/p/update-on-hacspec/</guid><description>&lt;img src="https://www.franziskuskiefer.de/p/update-on-hacspec/hacspec2-architecture.png" alt="Featured image of post Update on hacspec" />&lt;p>Earlier this year I introduced &lt;a class="link" href="../hacspec1" >hacspec, a new specification language for cryptographic primitives&lt;/a>.
After Karthik presented the idea and very preliminary results at &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/blob/master/doc/hacspec-short-talk-CFRG-IETF-101.pdf" target="_blank" rel="noopener"
>IETF 101&lt;/a> in March we made quite some progress and presented a paper with a little more detail at &lt;a class="link" href="https://ssr2018.net/" target="_blank" rel="noopener"
>SSR&lt;/a> earlier this week.
In this blog post I&amp;rsquo;ll give the gist of the &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/blob/master/doc/hacspec-ssr18-paper.pdf" target="_blank" rel="noopener"
>SSR paper&lt;/a> and introduce the first version of &lt;em>hacspec&lt;/em>.&lt;/p>
&lt;p>All information about &lt;em>hacspec&lt;/em> can be found at &lt;a class="link" href="https://hacs-workshop.github.io/hacspec/" target="_blank" rel="noopener"
>https://hacs-workshop.github.io/hacspec/&lt;/a>.&lt;/p>
&lt;h2 id="the-language">The language
&lt;/h2>&lt;p>The &lt;em>hacspec&lt;/em> language is a DSL for cryptographic algorithms.
But it can also be seen as a typed subset of Python.
The following describes the language.&lt;/p>
&lt;pre tabindex="0">&lt;code> Values v ::=
n integer constants
| True | False boolean constants
| &amp;#39;...&amp;#39; | &amp;#34;...&amp;#34; string constants
| (v1,...,vn) tuple constant
| array([v1,...,vn]) array constant
Expressions e ::=
v values
| x | m.x local and global variables
| (e1,...,en) tuple construction
| array([e1,...,en]) array construction
| array.length(e) array length
| e[e0] array access
| e[e0:e1] array slice
| e(e1,...,en) function call
| e1 binop e2 builtin binary operators
| unaryop e builtin unary operators
Types t ::=
int, str, bool basic types
| tuple_t(t1,...,tn) tuples
| vlarray_t(t) variable-length array
| x user-defined or builtin type
| x(t1,...,tn,e1,...,em) builtin type application
Statements s ::=
x: Type = t type declaration
| x: t variable declaration
| x = e variable assignment
| x binop= e augmented variable assignment
| (x1,..,xn) = e tuple matching
| x[i] = e array update
| x[i] binop= e augmented array update
| x[i:j] = e array slice update
| if e: if-elif-else conditional
s1...sn
elif e:
s1&amp;#39;...sn&amp;#39;
else
s1&amp;#39;&amp;#39;...sn&amp;#39;&amp;#39;
| for i in range(e): for loop
s1...sn
| break break from loop
| def x(x1:t1,...,xn:tn) -&amp;gt; t: function declaration
s1 ... sn
| return e return from function
| from x import x1, x2,..., xn module import
Specs σ ::= s1...sn sequence of statements
&lt;/code>&lt;/pre>&lt;h2 id="hacspec-architecture">hacspec architecture
&lt;/h2>&lt;p>The &lt;em>hacspec&lt;/em> architecture is depicted in the following graph.&lt;/p>
&lt;p>&lt;img src="https://www.franziskuskiefer.de/p/update-on-hacspec/hacspec2-architecture.png"
width="2873"
height="2451"
srcset="https://www.franziskuskiefer.de/p/update-on-hacspec/hacspec2-architecture_hu_8de99e7eeff4771e.png 480w, https://www.franziskuskiefer.de/p/update-on-hacspec/hacspec2-architecture_hu_950af34ffa8e638f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="117"
data-flex-basis="281px"
>&lt;/p>
&lt;h2 id="writing-hacspec">Writing hacspec
&lt;/h2>&lt;p>Every spec should be accompanied by a test and some test vectors leaving the author with at least two files, e.g. &lt;code>poly.py&lt;/code> and &lt;code>poly_test.py&lt;/code> (also see &lt;a class="link" href="#Example" >Example section&lt;/a>).
Note that only the spec file has to be &lt;em>hacspec&lt;/em> syntax.
The test file can make use of all of Python.
&lt;em>hacspec&lt;/em> comes with a standard library called speclib and a spec-checker.
To use the &lt;em>hacspec&lt;/em> speclib and spec-checker install them via &lt;code>pip install hacspec&lt;/code> or from the source (the &lt;code>setup.py&lt;/code> for the Python package can be found in &lt;code>/build/&lt;/code>).
Running &lt;em>hacspec&lt;/em> requires a Python interpreter version 3.6.4 or newer.&lt;/p>
&lt;h3 id="speclib">speclib
&lt;/h3>&lt;p>Commonly used functionality is provided in &lt;em>speclib&lt;/em> (&lt;code>from hacspec.speclib import *&lt;/code>).
The full speclib documentation can be found &lt;a class="link" href="https://hacs-workshop.github.io/hacspec/docs/" target="_blank" rel="noopener"
>here&lt;/a>.
Some highlights are&lt;/p>
&lt;ul>
&lt;li>&lt;em>modular arithmetic&lt;/em>: &lt;code>natmod_t&lt;/code> is an integer data type that provides modular arithmetic, e.g. &lt;code>felem_t = natmod_t((2**130)-5)&lt;/code> defines field elements modulo &lt;code>(2**130)-5&lt;/code>.&lt;/li>
&lt;li>&lt;em>machine integers&lt;/em>: &lt;code>unitN_t&lt;/code> define commonly used machine integer types for &lt;code>N = 8, 16, 32, 64, 128&lt;/code>.&lt;/li>
&lt;li>&lt;em>byte arrays, vectors, and matrices&lt;/em>: provided data structures are &lt;code>array_t, bytes_t, vector_t, matrix_t&lt;/code> as well as the variable length versions &lt;code>vlarray_t&lt;/code> and &lt;code>vlbytes_t&lt;/code>. Note that the vector and matrix data types offer point-wise arithmetic.&lt;/li>
&lt;li>&lt;em>refinements&lt;/em>: &lt;code>refine_t&lt;/code> allows to refine data types.&lt;/li>
&lt;li>&lt;em>contracts&lt;/em>: &lt;code>@contract&lt;/code> annotation on functions can be used for pre- and post-conditions.&lt;sup>1&lt;/sup>&lt;/li>
&lt;/ul>
&lt;h3 id="spec-checker">spec-checker
&lt;/h3>&lt;p>Since hacspecs are executed with a Python interpreter it is not sufficient to run &lt;em>hacspec&lt;/em> to check their syntax.
To check that the syntax is valid a spec-checker is provided.&lt;sup>2&lt;/sup>&lt;/p>
&lt;pre tabindex="0">&lt;code>hacspec-check &amp;lt;your-hacspec&amp;gt;
&lt;/code>&lt;/pre>&lt;h3 id="executing-hacspec">Executing hacspec
&lt;/h3>&lt;p>&lt;em>hacspec&lt;/em> tests are executed with the Python interpreter.
Executing tests on a spec can yield three different results.&lt;/p>
&lt;ol>
&lt;li>The execution is successful and all test vectors pass. In this case the spec is most likely correct and doesn&amp;rsquo;t contain any obvious typing issues.&lt;/li>
&lt;li>The execution fails because of a failing test case. In this case the spec is probably wrong (or the test vectors are incorrect).&lt;/li>
&lt;li>The execution fails because of a type error. The speclib as well as &lt;a class="link" href="https://github.com/agronholm/typeguard/" target="_blank" rel="noopener"
>typeguard&lt;/a> are used to perform runtime type checks.&lt;/li>
&lt;/ol>
&lt;h2 id="checking-and-compiling-hacspec">Checking and compiling hacspec
&lt;/h2>&lt;p>To use &lt;em>hacspecs&lt;/em> for formal verification such as verification of cryptographic properties of an algorithm, generating code in other languages from the spec, or verifying correctness of other implementations with it, a second set of tools is provided.
These tools are written in OCaml and thus require additional setup and are not packaged right now.&lt;sup>3&lt;/sup>
Check out the &lt;a class="link" href="https://github.com/HACS-workshop/hacspec" target="_blank" rel="noopener"
>repository&lt;/a> to use them.
All tools can be easily called via &lt;code>make&lt;/code> (see documentation in the repo &lt;code>/compiler/&lt;/code> for details).&lt;/p>
&lt;h3 id="type-checker">Type checker
&lt;/h3>&lt;p>To perform proper type checking Python is impractical.
A native type checker is implemented in OCaml that performs syntax and type checking for &lt;em>hacspec&lt;/em>.
To run the type checker on a spec simply run &lt;code>./checker.native &amp;lt;your-spec&amp;gt;&lt;/code>.&lt;/p>
&lt;h3 id="compiler">Compiler
&lt;/h3>&lt;p>The type checker also produces a typed AST that can be used to generate the spec in another formal language.
There are currently compiler for EasyCrypt and F*.
I&amp;rsquo;ll only describe the F* compiler as it&amp;rsquo;s more complete.&lt;/p>
&lt;h4 id="f-compiler">F* compiler
&lt;/h4>&lt;p>The F* compiler requires &lt;a class="link" href="https://github.com/mitls/hacl-star/" target="_blank" rel="noopener"
>&lt;code>HACL_HOME&lt;/code>&lt;/a> and &lt;a class="link" href="https://github.com/FStarLang/FStar" target="_blank" rel="noopener"
>&lt;code>FSTAR_HOME&lt;/code>&lt;/a> environment variables to be set.
The compiler is then invoked like this &lt;code>./to_fstar &amp;lt;your-spec&amp;gt;&lt;/code>.
The generated F* spec can then be type checked or executed on test vectors to check correctness of the spec.
Using &lt;a class="link" href="https://github.com/FStarLang/kremlin" target="_blank" rel="noopener"
>kremlin&lt;/a> the F* code can also be used to generate C code.&lt;/p>
&lt;h2 id="Example">Example
&lt;/h2>&lt;p>The &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/tree/master/specs" target="_blank" rel="noopener"
>&lt;em>hacspec&lt;/em> repo&lt;/a> has many examples.
I&amp;rsquo;ll only give a short one here.&lt;/p>
&lt;p>The spec &lt;code>poly.py&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Python" data-lang="Python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">hacspec.speclib&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">p130m5&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">nat_t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="mi">130&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">felem_t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">natmod_t&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p130m5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@typechecked&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">felem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">nat_t&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">felem_t&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">natmod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">p130m5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@typechecked&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">poly&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">vlarray_t&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">felem_t&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">felem_t&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">felem_t&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">acc&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">felem_t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">felem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">acc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">acc&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">r&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">acc&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The test &lt;code>poly_test.py&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Python" data-lang="Python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">poly&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">felem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x6f4620636968706172676f7470797243&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">felem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x6f7247206863726165736552206d7572&lt;/span>&lt;span class="p">)])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">felem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xa806d542fe52447f336d555778bed685&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">expected&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">natmod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xa01b776a69ea8c1cd3ba00179dc218ab&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p130m5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">poly&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">expected&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Error&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Expected: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">expected&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Got: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Test successful&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This can now be run with &lt;code>python poly_test.py&lt;/code> and checked with &lt;code>hacspec-check poly.py&lt;/code> and &lt;code>checker.native poly.py&lt;/code>.
Compiling this to F* can be done with &lt;code>to_fstar.native poly.py&lt;/code>, generating the following F* code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ocaml" data-lang="ocaml">&lt;span class="line">&lt;span class="cl">&lt;span class="k">module&lt;/span> &lt;span class="nc">Poly&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">open&lt;/span> &lt;span class="nc">Speclib&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">p130m5&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">nat_t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="o">**.&lt;/span> &lt;span class="n">130&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">-.&lt;/span> &lt;span class="n">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">felem_t&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="nc">Type0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">natmod_t&lt;/span> &lt;span class="n">p130m5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">felem&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">nat_t&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">felem_t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">natmod&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="n">p130m5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">poly&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">m&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">vlarray_t&lt;/span> &lt;span class="n">felem_t&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">r&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">felem_t&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">felem_t&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">acc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">felem&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">acc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">repeati&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">array_length&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">fun&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">acc&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">acc&lt;/span> &lt;span class="o">+.&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="o">.[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">*.&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">acc&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">acc&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="next-steps">Next steps
&lt;/h1>&lt;p>We hope that &lt;em>hacspec&lt;/em> is a useful tool for spec authors and many people indeed voiced interest already.
While the tooling isn&amp;rsquo;t perfect yet, the language is developed enough to start using it.
The next steps for &lt;em>hacspec&lt;/em> is to get some usage from spec authors and improve tooling.
We also hope to get more compilers for different formal languages implemented.&lt;/p>
&lt;br>
&lt;hr>
&lt;br>
&lt;ol>
&lt;li>Note that contracts are still in development and not fully supported yet.&lt;/li>
&lt;li>In future &lt;em>hacspec&lt;/em> syntax checks and running test vectors on the spec should be done in one invocation.&lt;/li>
&lt;li>In future pre-built binaries should be distributed to make this easier.&lt;/li>
&lt;/ol>
&lt;p>&lt;em>hacspec is mostly a spare time project for me at the moment. Development is therefore not always as fast as I&amp;rsquo;d like.&lt;/em>&lt;/p></description></item><item><title>Shipping (some) HACL*</title><link>https://www.franziskuskiefer.de/p/shipping-some-hacl/</link><pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.franziskuskiefer.de/p/shipping-some-hacl/</guid><description>&lt;img src="https://www.franziskuskiefer.de/p/shipping-some-hacl/hero.jpg" alt="Featured image of post Shipping (some) HACL*" />&lt;p>If you didn&amp;rsquo;t read the article about the &lt;a class="link" href="../hacl-star/" >HACL* approach&lt;/a>, go there first and read it. tl;dr&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="https://github.com/mitls/hacl-star/" target="_blank" rel="noopener"
>HACL*&lt;/a> is a cryptographic library written in &lt;a class="link" href="https://www.fstar-lang.org/" target="_blank" rel="noopener"
>F*&lt;/a> that allows translation to C using kremlin.
It guarantees memory safety, secret independent computation, and functional correctness with respect to a mathematical specification.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;p>In this second blog post I describe the process of integrating code from HACL*, a researchy crypto library, into NSS, a production library shipping to millions of people, running on a plethora of platforms.
In short, how to ship (some parts of) HACL*.&lt;/p>
&lt;h1 id="shipping-formally-verified-code">Shipping formally verified code
&lt;/h1>&lt;p>Before integrating any code from HACL* into NSS there had to be some criteria the code had to fulfil in order to get considered and a process of integrating, maintaining, and updating the code.
The criteria roughly looked like this:&lt;/p>
&lt;ul>
&lt;li>The code has to be correct.&lt;/li>
&lt;li>Performance must not be degraded by any new code.&lt;/li>
&lt;li>The code has to be human readable and modifiable, i.e. it must pass a code review process.&lt;/li>
&lt;li>The code must run on all platforms supported by NSS or must have fallback code for platforms that are not supported.&lt;/li>
&lt;li>Upstream changes can to be integrated easily into NSS and fixes can be integrated upstream.&lt;/li>
&lt;li>The verification and generation toolchain has to run in the NSS world.&lt;/li>
&lt;/ul>
&lt;p>We started integrating HACL* crypto primitives into NSS with &lt;a class="link" href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener"
>Curve25519&lt;/a>.
At the time of writing NSS contains code from HACL* for Curve25519 64-bit, &lt;a class="link" href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener"
>Poly1305&lt;/a> 32-bit and 64-bit, &lt;a class="link" href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener"
>ChaCha20&lt;/a>, and ChaCha20 with SSSE3 hardware acceleration.
More primitives are in the pipeline and will be integrated in the near future.&lt;/p>
&lt;h2 id="correctness">Correctness
&lt;/h2>&lt;p>Any code that lands in NSS has to be correct, obviously.
This might be evident but when talking about HACL* generated C code, correctness is not so simple.
Correctness can be checked relatively easily by looking at the HACL* specification of a given primitive.
This code is relatively easy to review (when familiar with F*) as it closely resembles the mathematical specification of the primitive.
The correctness of the C code is guaranteed by the formal proofs from HACL*.
In addition we run all the usual test vectors on it of course.
To catch any errors in the extraction chain from F* to C the extracted C code is reviewed for correctness as well.&lt;/p>
&lt;h2 id="performance">Performance
&lt;/h2>&lt;p>Performance was not a big concern.
As shown in the &lt;a class="link" href="https://github.com/mitls/hacl-star/blob/master/doc/papers/hacl-star-ccs2017.pdf" target="_blank" rel="noopener"
>HACL* paper from CCS 2017&lt;/a>, performance of most primitives is on par with or better than the fastest C implementations out there.
Nonetheless, performance of each primitive is compared between HACL* and the NSS to make sure not to degrade performance.
For every primitive I looked at so far the performance of HACL* was at least as good as the performance of the NSS code.&lt;/p>
&lt;h2 id="code-quality">Code quality
&lt;/h2>&lt;p>Code quality was, as with any generated code, a big concern.
How readable is the generated code? Can it easily be changed if the need arises?
The first versions we looked at weren&amp;rsquo;t that great &amp;hellip;&lt;/p>
&lt;p>&lt;img src="https://www.franziskuskiefer.de/p/shipping-some-hacl/hacl-review.png"
width="1983"
height="747"
srcset="https://www.franziskuskiefer.de/p/shipping-some-hacl/hacl-review_hu_dc7cc53ebaebad91.png 480w, https://www.franziskuskiefer.de/p/shipping-some-hacl/hacl-review_hu_9b604c9cc957aac.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="265"
data-flex-basis="637px"
>
&lt;img src="https://www.franziskuskiefer.de/p/shipping-some-hacl/ugly-hacl.png"
width="755"
height="147"
srcset="https://www.franziskuskiefer.de/p/shipping-some-hacl/ugly-hacl_hu_a335ff08fbc7a63a.png 480w, https://www.franziskuskiefer.de/p/shipping-some-hacl/ugly-hacl_hu_67d61d8e2d1f243c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="513"
data-flex-basis="1232px"
>&lt;/p>
&lt;p>But after a couple improvements to kremlin the code was good to go.
While every new piece of code that&amp;rsquo;s being integrated has to pass code review the C code produced by kremlin is good enough now to land new primitives without having to improve upstream code first.
Note however that code passes review here that wouldn&amp;rsquo;t pass if it were hand-written.
The code generator is not perfect.
We have to live with some rough edges.
The most important point is that the code is understandable.&lt;/p>
&lt;p>NSS if formatted with &lt;code>clang-format&lt;/code>, which is checked on CI.
So the only change to the verified C code imported from HACL* is formatting.&lt;/p>
&lt;h3 id="some-pain-points-remain">Some pain points remain
&lt;/h3>&lt;p>There are some outstanding issues that I hope get fixed in kremlin and would improve code quality significantly.
Kremlin doesn&amp;rsquo;t know &lt;code>const&lt;/code>, which is one of the few nice helpers one can use in C to control what&amp;rsquo;s happening to your pointer.
While &lt;code>const&lt;/code> is not necessary because of the HACL* proofs, it would be nice to have.
Kremlin further generates unnecessary casts such as &lt;code>(uint32_t)4U&lt;/code>.
This is not a big deal but makes code harder to read.
There&amp;rsquo;s also a big number of temporary variables that aren&amp;rsquo;t necessary and make the code harder to read.&lt;/p>
&lt;h2 id="platform-support">Platform support
&lt;/h2>&lt;p>Being a researchy library HACL* is not tested on a big variety of platforms.
NSS on the other hand has to run on most available platforms as well as a number of legacy platforms.
While the NSS CI covers Windows, Linux, and Mac in different configurations such as Intel 32-bit, 64-bit, and aarch64, there are other platforms such as BSD using NSS that are not covered.
As expected we ran into a couple issues on some platforms such as BSD and Solaris but they were quickly resolved.&lt;/p>
&lt;p>&lt;img src="https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-bsd-hacl-bug.png"
width="2048"
height="184"
srcset="https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-bsd-hacl-bug_hu_22de423f74418db3.png 480w, https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-bsd-hacl-bug_hu_fe22262a6f4debb0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1113"
data-flex-basis="2671px"
>&lt;/p>
&lt;p>&lt;img src="https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-solaris-hacl-bug.png"
width="2048"
height="184"
srcset="https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-solaris-hacl-bug_hu_880cd95fb94c19bd.png 480w, https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-solaris-hacl-bug_hu_3d611ef34f96cbd.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1113"
data-flex-basis="2671px"
>&lt;/p>
&lt;p>Especially code that is hardware dependent such as Intel intrinsics needs extra attention.
The &lt;a class="link" href="https://github.com/mitls/hacl-star/blob/master/snapshots/kremlib/vec128.h" target="_blank" rel="noopener"
>&lt;code>vec128.h&lt;/code>&lt;/a> header used by HACL* to abstract hardware instructions needed a couple iterations before it worked on all supported platforms.&lt;/p>
&lt;h2 id="handling-change">Handling change
&lt;/h2>&lt;p>The code imported from HACL* into NSS is not expected to change a lot.
But there are always reasons why the code has to get updated and a process is required to do so.
To fix issues like broken platforms, changes to the upstream projects have to be landed and the snapshot in NSS has to get updated to the new upstream version.
For this process to run smoothly it&amp;rsquo;s necessary for both teams to work together.&lt;/p>
&lt;p>Updating the HACL* code in NSS is pretty easy.
First the new code is generated with a new version of HACL*, formatted, and copied to NSS.
Then the docker image running the CI gets updated.
Here&amp;rsquo;s a diff for a recent update.&lt;/p>
&lt;p>&lt;img src="https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-hacl-patch.png"
width="2922"
height="1264"
srcset="https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-hacl-patch_hu_cd3aa9c5c2b53aa9.png 480w, https://www.franziskuskiefer.de/p/shipping-some-hacl/nss-hacl-patch_hu_7a01cd98eb0314ff.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="231"
data-flex-basis="554px"
>&lt;/p>
&lt;h2 id="running-the-verification-in-nss">Running the verification in NSS
&lt;/h2>&lt;p>To make sure that whatever we use in NSS actually verifies and the generated code isn&amp;rsquo;t changed manually, the NSS CI has to verify the HACL* snapshot it uses on every run.
NSS uses &lt;a class="link" href="https://github.com/taskcluster" target="_blank" rel="noopener"
>taskcluster&lt;/a> as CI, which allows us to use a &lt;a class="link" href="https://searchfox.org/nss/source/automation/taskcluster/docker-hacl" target="_blank" rel="noopener"
>docker image&lt;/a> that re-verifies the used HACL* revision on every push.
Checking the code in NSS is then a simple diff.&lt;/p>
&lt;h1 id="lessons-learned">Lessons learned
&lt;/h1>&lt;p>The first lesson is that it&amp;rsquo;s possible to ship formally verified software.
The code is relatively simple and self-contained, which makes this easier.
But it shows that formal verification tools are good enough to be used in production.&lt;/p>
&lt;p>The second lesson we learned is probably the more valuable one.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Talk to each other and work together.&lt;/em>&lt;/p>&lt;/blockquote>
&lt;p>From an engineering standpoint it might be frightening to start looking at formal verification tools and corresponding languages.
But people working with these tools are happy to help out if that means more people are using their tools.
It will need some effort getting used to the tools and languages but it&amp;rsquo;s well worth it.&lt;/p>
&lt;p>For people working on formal methods; You might have to learn a little more than you wanted to know about differences between different platforms and compilers and how to ship software.
But that might be worth the effort if it means your proofs are used in production software that&amp;rsquo;s used by millions of people.&lt;/p>
&lt;hr>
&lt;p>Looking for more material on this?
There&amp;rsquo;s a high-level &lt;a class="link" href="https://blog.mozilla.org/security/2017/09/13/verified-cryptography-firefox-57/" target="_blank" rel="noopener"
>blog post&lt;/a> that talks about the formal verification work in NSS happening at Mozilla.
There has also been a talk at RWC 2018 earlier this year on this work (&lt;a class="link" href="https://rwc.iacr.org/2018/Slides/Beurdouche.pdf" target="_blank" rel="noopener"
>slides&lt;/a>, &lt;a class="link" href="https://www.youtube.com/watch?v=xrZTVRICpSs" target="_blank" rel="noopener"
>video&lt;/a>).&lt;/p></description></item><item><title>The HACL* approach</title><link>https://www.franziskuskiefer.de/p/the-hacl-approach/</link><pubDate>Wed, 14 Feb 2018 00:00:00 +0000</pubDate><guid>https://www.franziskuskiefer.de/p/the-hacl-approach/</guid><description>&lt;img src="https://www.franziskuskiefer.de/p/the-hacl-approach/hacl-chart.png" alt="Featured image of post The HACL* approach" />&lt;p>HACL* (High-Assurance Cryptographic Library) is a formally verified cryptographic library in &lt;a class="link" href="https://www.fstar-lang.org/" target="_blank" rel="noopener"
>F*&lt;/a>, developed by the &lt;a class="link" href="http://prosecco.inria.fr/" target="_blank" rel="noopener"
>Prosecco team&lt;/a> at &lt;a class="link" href="https://www.inria.fr/en/centre/paris" target="_blank" rel="noopener"
>INRIA Paris&lt;/a> in collaboration with Microsoft Research, as part of &lt;a class="link" href="https://github.com/project-everest" target="_blank" rel="noopener"
>Project Everest&lt;/a>.
HACL* was inspired by discussions at the &lt;a class="link" href="https://hacs-workshop.github.io/" target="_blank" rel="noopener"
>HACS workshop&lt;/a> and aims at developing a set of reference implementations in C for common cryptographic primitives.&lt;/p>
&lt;p>This is the first post in a series describing formal verification in NSS as an approach to improve confidence in highly complex, highly security critical code.
In this first post I describe the most important ideas and concepts of HACL*, the basis of most formally verified code in NSS.
If you want to have all the juicy details about HACL*, I recommend reading the &lt;a class="link" href="https://github.com/mitls/hacl-star/blob/master/doc/papers/hacl-star-ccs2017.pdf" target="_blank" rel="noopener"
>CCS'17 paper&lt;/a>.&lt;/p>
&lt;h1 id="hacl">HACL*
&lt;/h1>&lt;p>HACL*, though written in F*, can be compiled to C code with guaranteed memory safety, secret independent computation, and functional correctness with respect to some mathematical specification.
Let&amp;rsquo;s first have a look at the high-level idea of HACL* on the example of Curve25519.&lt;/p>
&lt;p>The first step is to take the specification (&lt;a class="link" href="https://tools.ietf.org/html/rfc7748" target="_blank" rel="noopener"
>RFC 7748&lt;/a> in this case) and translate it into a high level F* specification.
This specification is easy to read and can be checked for correctness against the RFC easily.
All correctness guarantees HACL* gives for the generated C code are based on this specification, i.e. the C code is proven to be functionally equivalent to the the high level specification.
Here the definition of the Montgomery ladder, an excerpt from the &lt;a class="link" href="https://github.com/mitls/hacl-star/blob/dev_specs/specs/Spec.Curve25519.fst" target="_blank" rel="noopener"
>Curve25519 specification&lt;/a>. (Apologies for the highlighting, no F* support.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ocaml" data-lang="ocaml">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="k">rec&lt;/span> &lt;span class="n">montgomery_ladder_&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">elem&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">xp1&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">scalar&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ctr&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">nat&lt;/span>&lt;span class="o">{&lt;/span>&lt;span class="n">ctr&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">256&lt;/span>&lt;span class="o">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="o">:&lt;/span> &lt;span class="nc">Tot&lt;/span> &lt;span class="n">proj_point&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">decreases&lt;/span> &lt;span class="n">ctr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">ctr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">ctr&amp;#39;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ctr&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">x&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">xp1&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">uint_to_nat&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ith_bit&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">ctr&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="o">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">nqp2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">nqp1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">add_and_double&lt;/span> &lt;span class="n">init&lt;/span> &lt;span class="n">xp1&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">nqp1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">nqp2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="o">)&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">add_and_double&lt;/span> &lt;span class="n">init&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">xp1&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">montgomery_ladder_&lt;/span> &lt;span class="n">init&lt;/span> &lt;span class="n">x&amp;#39;&lt;/span> &lt;span class="n">xp1&amp;#39;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">ctr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">&lt;span class="o">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Running the reference implementation is possible but obviously slow (it is executed in OCaml).
However a subset of F* (called Low*) can be translated to C using &lt;a class="link" href="https://github.com/FStarLang/kremlin" target="_blank" rel="noopener"
>Kremlin&lt;/a>.
While the specification might be valid Low* code it is not optimised and thus won&amp;rsquo;t yield fast C code.
In order to generate fast C code more efficient Low* code has to be written first.
Looking at state of the art C code for the given algorithm (&lt;a class="link" href="https://github.com/jedisct1/libsodium/blob/e878bc141be12820dc6dbcd7a97bf50070bc1e2a/src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c" target="_blank" rel="noopener"
>Curve25519 Donna&lt;/a> for example) Low* code can be written that resembles the fast C code and can be extracted via Kremlin to similarly looking C code.&lt;/p>
&lt;p>At this point the main benefit of the HACL* approach comes to light.
The optimised Low* code (as well as the extracted C code) are hard to get right and even harder to review for correctness, memory safety, and secret independent execution.
Using an SMT solver (&lt;a class="link" href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener"
>Z3&lt;/a> is used in HACL*) and F*&amp;rsquo;s strong type system, functional equivalence is proven between the high-level F* specification and the optimised Low* code.
The Low* code usually has to be enhanced with additional information to help prove the equivalence.
This additional code however is ignored by Kremlin and doesn&amp;rsquo;t get translated to C.&lt;/p>
&lt;p>The following graphic gives an overview of the HACL* process.&lt;/p>
&lt;p>&lt;img src="https://www.franziskuskiefer.de/p/the-hacl-approach/hacl-chart.png"
width="842"
height="595"
srcset="https://www.franziskuskiefer.de/p/the-hacl-approach/hacl-chart_hu_9683bf7354fc0b1e.png 480w, https://www.franziskuskiefer.de/p/the-hacl-approach/hacl-chart_hu_7cbcf00e30c5a9f0.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;h2 id="an-example---conditional-swap">An Example - Conditional Swap
&lt;/h2>&lt;p>HACL* is a pretty complex library and it might be hard to understand what&amp;rsquo;s going on.
Therefore I&amp;rsquo;ll give a small example of the basic concepts behind HACL* focusing on functional correctness.&lt;/p>
&lt;p>Conditional swaps are used for example in Curve25519 implementations to swap two variables &lt;code>a&lt;/code> and &lt;code>b&lt;/code> if a certain condition is given, &lt;code>c = 0&lt;/code> here.
In F* this can be written as follows.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ocaml" data-lang="ocaml">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="n">cswap&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="nc">Tot&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">uint32&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">cswap&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0ul&lt;/span> &lt;span class="k">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl"> &lt;span class="o">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>This code can be easily inspected for correctness and is used as specification.
However, this is not the code we want to have as it branches on potentially secret data in &lt;code>c&lt;/code>.
Instead of checking &lt;code>c&lt;/code> for &lt;code>0&lt;/code> we should use masking and logical operations to achieve the variable swapping.
Note that we require &lt;code>c&lt;/code> to be either all &lt;code>1&lt;/code> or all &lt;code>0&lt;/code> now.
This can be easily computed from the single bit &lt;code>c&lt;/code> we had in the previous example.
This looks as follows in pseudo-C-code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">cswap_constant_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">uint32_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">mask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">mask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">mask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>The same code in F* (with slightly different input/output behaviour) looks as follows.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ocaml" data-lang="ocaml">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="n">cswap_constant_time&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">uint32&lt;/span>&lt;span class="o">{&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0xFFFFFFFFul&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">/&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0ul&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="nc">Tot&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">uint32&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">uint32&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">cswap_constant_time&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">mask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">^^&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;^&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">^^&lt;/span> &lt;span class="n">mask&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="k">let&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">^^&lt;/span> &lt;span class="n">mask&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl"> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>This code is not trivially correct anymore and requires considerable thought by both author and reviewer.
But instead of staring at the code to understand it or writing incomplete tests we can use F* now to prove that &lt;code>cswap_constant_time&lt;/code> is equivalent to our spec, i.e. &lt;code>cswap&lt;/code>.
To this end we write a lemma to ensures that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ocaml" data-lang="ocaml">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cswap_constant_time&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="k">let&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cswap&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="k">in&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">d&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>While this can&amp;rsquo;t be proven immediately it is relatively easy to write some helper lemmata that help F* and Z3 to understand the correctness of this statement.
The C code extracted by Kremlin from the F* code above then looks as follows.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">fst&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">snd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="n">K___uint32_t_uint32_t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="n">K___uint32_t_uint32_t&lt;/span> &lt;span class="nf">Impl_CSwap_cswap_constant_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">K___uint32_t_uint32_t&lt;/span>&lt;span class="p">){&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">fst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">snd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">9&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Check out the &lt;a class="link" href="https://github.com/franziskuskiefer/the-hacl-approach" target="_blank" rel="noopener"
>repository&lt;/a> for the full source code of the example.&lt;/p>
&lt;p>Memory safety can be proven easily as well by specifying liveliness conditions of buffers.
In this example we don&amp;rsquo;t have buffers so no need for verifying memory safety.
We skip proving secret-independent execution here as it requires additional support from HACL*.&lt;/p>
&lt;h1 id="code-generation-vs-code-verification">Code Generation vs Code Verification
&lt;/h1>&lt;p>The HACL* approach as described above is a great way of generating fast C code that&amp;rsquo;s proven to be correct, memory safe, and have secret-independent runtime.
For &lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS" target="_blank" rel="noopener"
>NSS&lt;/a> we decided to use code generation and integrate code from HACL* into the code base.
However, instead of generating code it would also be possible to verify existing C code with other tools such as Cryptol/SAW to prove similar properties of the code.&lt;/p>
&lt;p>The main advantage of code generation is that the mathematical specifications can be easily used to build more complex algorithms and protocols on top and allow for re-use of specification code.
The trusted code base written in F* is therefore very small.&lt;/p>
&lt;p>The main drawback of generating code is a relatively large third-party code base that has to be trusted in order to generate the code.
The weakest link in the case of HACL* is probably Kremlin, which has a &lt;a class="link" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/icfp17main-main96-p-5064b17-32755-submitted.pdf" target="_blank" rel="noopener"
>hand written proof&lt;/a> but is a relatively young piece of code that probably contains bugs.&lt;/p>
&lt;p>There is no optimal solution to this problem that works for everyone but the HACL* approach as described in this post is a great way to get better confidence in correctness and security of complex C code using formal verification.&lt;/p>
&lt;p>In the next post I&amp;rsquo;ll talk about challenges we faced when integrating code from HACL* into NSS and how we solved them.&lt;/p></description></item><item><title>Introducing HacSpec</title><link>https://www.franziskuskiefer.de/p/introducing-hacspec/</link><pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate><guid>https://www.franziskuskiefer.de/p/introducing-hacspec/</guid><description>&lt;img src="https://www.franziskuskiefer.de/p/introducing-hacspec/hero.png" alt="Featured image of post Introducing HacSpec" />&lt;p>HacSpec is a proposal for a new specification language for cryptographic primitives that is succinct, that is easy to read and implement, and that lends itself to formal verification.
It aims to formalise the pseudocode used in cryptographic standards by proposing a formal syntax that can be checked for simple errors.
HacSpec specifications are further executable to test against test vectors specified in a common syntax.&lt;/p>
&lt;p>The main focus of HacSpec is to allow specifications to be compiled to formal languages such as cryptol, coq, F*, and easycrypt and thus make it easier to formally verify implementations.
This allows a specification using HacSpec to be the basis not only for implementations but also for formal proofs of functional correctness, cryptographic security, and side-channel resistance.&lt;/p>
&lt;p>The idea of having a language like HacSpec stems from discussions at the recent HACS workshop in Zurich.
The &lt;a class="link" href="https://hacs-workshop.github.io/" target="_blank" rel="noopener"
>High-Assurance-Cryptographic-Software workshop (HACS)&lt;/a> is an invite-only workshop co-located with the &lt;a class="link" href="https://rwc.iacr.org/" target="_blank" rel="noopener"
>Real World Crypto&lt;/a> symposium.&lt;/p>
&lt;p>Anyone interested in moving this project forward should subscribe to the &lt;a class="link" href="https://moderncrypto.org/mail-archive/hacspec/" target="_blank" rel="noopener"
>mailing list&lt;/a> or file issues and pull requests against the &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/" target="_blank" rel="noopener"
>Github repository&lt;/a>.&lt;/p>
&lt;h2 id="how-far-are-we">How far are we?
&lt;/h2>&lt;p>We discussed and hacked at HACS a month ago and improved a little over the last weeks.
The current state can be found at &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/" target="_blank" rel="noopener"
>Github repository&lt;/a>.&lt;/p>
&lt;h3 id="the-language">The language
&lt;/h3>&lt;p>There are &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/tree/master/specs" target="_blank" rel="noopener"
>examples&lt;/a> written in what we believe could be the HacSpec.
The language is valid Python 3.6 using PEP484 and PEP526 for typing.
It further uses comments (similar to PEP484 types) to define lengths and ranges.&lt;/p>
&lt;p>There are also &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/tree/master/specs/hacspec-rust" target="_blank" rel="noopener"
>experiments using Rust&lt;/a> as basis for HacSpec.
While Rust&amp;rsquo;s type system makes it a compelling candidate, limitations in handling integers of arbitrary size means we probably won&amp;rsquo;t be basing HacSpec on Rust.&lt;/p>
&lt;p>The &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/blob/master/LANGUAGE.md" target="_blank" rel="noopener"
>language specification&lt;/a> is currently vague and not fully formalised yet.
It lives in a markdown document but will move to an RFC layout later.&lt;/p>
&lt;h3 id="formal-specifications">Formal specifications
&lt;/h3>&lt;p>To show how cryptographic primitives are modelled in formal languages we added a number of &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/tree/master/formal-models" target="_blank" rel="noopener"
>specifications&lt;/a> in different languages such as cryptol, coq, F*, and easycrypt to the repository.&lt;/p>
&lt;h3 id="spec-checker">Spec checker
&lt;/h3>&lt;p>In order to verify whether a specification is a valid HacSpec Aaron started to implement a &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/tree/master/spec-checker" target="_blank" rel="noopener"
>spec-checker&lt;/a>.
Basing HacSpec on another language like Python means that not all valid Python programs are valid HacSpec programs.
The spec checker is supposed to tell authors whether a given python program is a valid HacSpec.&lt;/p>
&lt;h3 id="compilers">Compilers
&lt;/h3>&lt;p>There&amp;rsquo;s currently a very basic &lt;a class="link" href="https://github.com/HACS-workshop/hacspec/tree/master/spec-compilers" target="_blank" rel="noopener"
>HacSpec to F* compiler&lt;/a> from Karthik.
Eventually we would like to have compilers from HacSpec to all common formal languages such as cryptol, coq, F*, and easycrypt.&lt;/p>
&lt;h2 id="call-for-participation">Call for participation
&lt;/h2>&lt;p>We invite contributions in the following areas.&lt;/p>
&lt;ul>
&lt;li>We invite people to submit “standalone&amp;quot; formal specs for inclusion in the formal-models directory.&lt;/li>
&lt;li>We invite formal methods people to build compilers from HacSpec to their favourite modelling language.&lt;/li>
&lt;li>We invite spec authors and developers to comment on HacSpec and provide examples of what they consider good crypto specs or beautiful “obviously correct” crypto implementations.&lt;/li>
&lt;li>We invite developers to build compilers from HacSpec to their favourite programming language.&lt;/li>
&lt;/ul>
&lt;h2 id="what-hacspec-is-not-about">What HacSpec is not about
&lt;/h2>&lt;p>HacSpec does &lt;em>not&lt;/em> aim to be general enough to express protocols at this point. While this might be a target in the future the first iteration of HacSpec is only targeting crypto primitives.&lt;/p>
&lt;h2 id="links">Links
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/HACS-workshop/hacspec/" target="_blank" rel="noopener"
>Github repository&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://moderncrypto.org/mail-archive/hacspec/" target="_blank" rel="noopener"
>Mailing list&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>