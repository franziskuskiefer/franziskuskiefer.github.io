<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Franziskus Kiefer</title>
    <link>https://www.franziskuskiefer.de/</link>
    <description>Recent content on Franziskus Kiefer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.franziskuskiefer.de/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>OpenMLS Performance</title>
      <link>https://www.franziskuskiefer.de/post/openmls-first-benchmarks/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/openmls-first-benchmarks/</guid>
      <description>The Messaging Layer Security (MLS) protocol is an IETF proposal for group key establishment and message protection. OpenMLS is a Rust implementation of the MLS protocol in its current state (draft 11 as of the point of writing this) that is being implemented by Raphael, Konrad and myself. For more general information on MLS I refer to the spec and other blog posts. This blog post is only about MLS, and in particular OpenMLS, performance.</description>
    </item>
    
    <item>
      <title>üí≤ Web Monetization üí≤</title>
      <link>https://www.franziskuskiefer.de/post/webmonetization/</link>
      <pubDate>Sun, 14 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/webmonetization/</guid>
      <description>Thanks to Deez I gave web monetization a spin on this website today. Here I write up how I did it, how it went, and what I think about it.
The proposed web monetization standard allows browsers to securely pay websites, and, in turn, allows for websites to react to being paid, for example by turning off ads or providing extra functionality to paying visitors. There is some good description of use cases on Coil&amp;rsquo;s website if you&amp;rsquo;re looking for a more general explainer.</description>
    </item>
    
    <item>
      <title>Asynchronous Remote Key Generation: An Analysis of Yubico&#39;s Proposal for W3C WebAuthn</title>
      <link>https://www.franziskuskiefer.de/publications/arkg/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/arkg/</guid>
      <description>WebAuthn, forming part of FIDO2, is a W3C standard for strong authentication, which employs digital signatures to authenticate web users whilst preserving their privacy. Owned by users, WebAuthn authenticators generate attested and unlinkable public-key credentials for each web service to authenticate users. Since the loss of authenticators prevents users from accessing web services, usable recovery solutions preserving the original WebAuthn design choices and security objectives are urgently needed.
We examine Yubico&amp;rsquo;s recent proposal for recovering from the loss of a WebAuthn authenticator by using a secondary backup authenticator.</description>
    </item>
    
    <item>
      <title>I&#39;m leaving AISEC</title>
      <link>https://www.franziskuskiefer.de/post/leaving-aisec/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/leaving-aisec/</guid>
      <description>I don&amp;rsquo;t like to write a post like this but I really feel that this one is necessary. After not even half a year I&amp;rsquo;m going to leave the Fraunhofer AISEC at the end of May. In this post I want to explain why.
This is not a post about contact tracing!
During the week of April 13 the controversy around PEPP-PT started to heat up. Articles from coindesk and other media such as Golem (German), started to pop up and I started to get a little concerned knowing that AISEC is part of the PEPP-PT organization.</description>
    </item>
    
    <item>
      <title>Shared-Secrets Service</title>
      <link>https://www.franziskuskiefer.de/post/shared-secrets-service/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/shared-secrets-service/</guid>
      <description>At the Berlin Crypto this month we had a talk by Kevin about a shared-secret service they developed at Syselevn. After experimenting with PGP and deciding that it doesn&amp;rsquo;t do what they needed, they decided to go with a very simple, custom encrypt-then-mac scheme. You can find details here. When someone says they built their own encryption scheme and message format I get obviously curious. In this post I want to summarize the scheme, design decisions, compare it standard authenticated encryption schemes, and ponder the question of the right security definitions.</description>
    </item>
    
    <item>
      <title>Mozilla SURF Summit Vienna 2019</title>
      <link>https://www.franziskuskiefer.de/post/surf-vienna-2019/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/surf-vienna-2019/</guid>
      <description>Last week we had the third Security Engineering University Relationship Framework (SURF) summit in Vienna. The last SURF summit I attended was the first one in London 2018.
This time we had four talks by Mozillians, three invited talks, as well as eight lightning talks. I live-tweeted a little during the event if you like slides on photos.
Christoph talked about how to harden the content security landscape of Firefox and posed the question how we could do some of that on the web.</description>
    </item>
    
    <item>
      <title>Wrapping arithmetic in Rust</title>
      <link>https://www.franziskuskiefer.de/post/wrapping-arithmetic/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/wrapping-arithmetic/</guid>
      <description>One of Rusts great feature is that it catches integer overflows at runtime and panics rather than wraps (in debug builds). I recommend you read Huon&amp;rsquo;s blog post about this from a couple years ago.
While this is a desirable behaviour in general, integer overflows are commonly used when implementing cryptography primitives. Rust offers wrapping alternatives such as wrapping_add etc. to allow wrapping behaviour. However, this makes code very hard to read, e.</description>
    </item>
    
    <item>
      <title>Update on hacspec</title>
      <link>https://www.franziskuskiefer.de/post/hacspec2/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacspec2/</guid>
      <description>Earlier this year I introduced hacspec, a new specification language for cryptographic primitives. After Karthik presented the idea and very preliminary results at IETF 101 in March we made quite some progress and presented a paper with a little more detail at SSR earlier this week. In this blog post I&amp;rsquo;ll give the gist of the SSR paper and introduce the first version of hacspec.
All information about hacspec can be found at https://hacs-workshop.</description>
    </item>
    
    <item>
      <title>hacspec: towards verifiable crypto standard</title>
      <link>https://www.franziskuskiefer.de/publications/hacspec18/</link>
      <pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/hacspec18/</guid>
      <description>We present hacspec, a collaborative effort to design a formal specification language for cryptographic primitives. Specifications (specs) written in hacspec are succinct, easy to read and implement, and lend themselves to formal verification using a variety of existing tools. The syntax of hacspec is similar to the pseudocode used in cryptographic standards but is equipped with a static type system and syntax checking tools that can find errors. Specs written in hacspec are executable and can hence be tested against test vectors taken from standards and specified in a common format.</description>
    </item>
    
    <item>
      <title>Mozilla Security Research Summit London 2018</title>
      <link>https://www.franziskuskiefer.de/post/surf-london-2018/</link>
      <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/surf-london-2018/</guid>
      <description>The Security Engineering University Relationship Framework (SURF) is an initiative within the Firefox security engineering team to improve relations with privacy and security researchers. SURF includes a variety of possible relationships but is focused on building long-term relationships with researchers and organisations. The goal of SURF projects is to explore topics that are outside of Mozilla&amp;rsquo;s immediate product needs, influence Mozilla&amp;rsquo;s long-term product development and vision.
On November 12th the first SURF summit was held in London.</description>
    </item>
    
    <item>
      <title>Shipping (some) HACL*</title>
      <link>https://www.franziskuskiefer.de/post/hacl-nss-integration/</link>
      <pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacl-nss-integration/</guid>
      <description>If you didn&amp;rsquo;t read the article about the HACL* approach, go there first and read it. tl;dr
 HACL* is a cryptographic library written in F* that allows translation to C using kremlin. It guarantees memory safety, secret independent computation, and functional correctness with respect to a mathematical specification.
 In this second blog post I describe the process of integrating code from HACL*, a researchy crypto library, into NSS, a production library shipping to millions of people, running on a plethora of platforms.</description>
    </item>
    
    <item>
      <title>The HACL* approach</title>
      <link>https://www.franziskuskiefer.de/post/hacl-star/</link>
      <pubDate>Wed, 14 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacl-star/</guid>
      <description>HACL* (High-Assurance Cryptographic Library) is a formally verified cryptographic library in F*, developed by the Prosecco team at INRIA Paris in collaboration with Microsoft Research, as part of Project Everest. HACL* was inspired by discussions at the HACS workshop and aims at developing a set of reference implementations in C for common cryptographic primitives.
This is the first post in a series describing formal verification in NSS as an approach to improve confidence in highly complex, highly security critical code.</description>
    </item>
    
    <item>
      <title>Introducing HacSpec</title>
      <link>https://www.franziskuskiefer.de/post/hacspec1/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/hacspec1/</guid>
      <description>HacSpec is a proposal for a new specification language for cryptographic primitives that is succinct, that is easy to read and implement, and that lends itself to formal verification. It aims to formalise the pseudocode used in cryptographic standards by proposing a formal syntax that can be checked for simple errors. HacSpec specifications are further executable to test against test vectors specified in a common syntax.
The main focus of HacSpec is to allow specifications to be compiled to formal languages such as cryptol, coq, F*, and easycrypt and thus make it easier to formally verify implementations.</description>
    </item>
    
    <item>
      <title>CVE-2017-5462 - A PRNG issue</title>
      <link>https://www.franziskuskiefer.de/post/cve-2017-5462/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/cve-2017-5462/</guid>
      <description>On April 19, 2017, Mozilla Foundation published the Security Advisory 2017-10 outlining several recently fixed security vulnerabilities. One of these vulnerabilities, tracked as CVE-2017-5462, affects the Pseudo-Random Number Generator (PRNG) within the Network Security Services (NSS) library prior to version 3.29.5 and Firefox prior to version 53.
This post describes the bug and how it was discovered.
Inside the NSS PRNG NSS uses Hash_DRBG as PRNG, which is one of several PRNG schemes defined in the NIST Special Publication 800-90.</description>
    </item>
    
    <item>
      <title>New Website</title>
      <link>https://www.franziskuskiefer.de/post/new-blog/</link>
      <pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/new-blog/</guid>
      <description>After a couple of years using ghost I switched to the static page generator hugo. Hugo is easy to write and easy to publish. But more importantly it doesn&amp;rsquo;t offer the attack surface ghost does and doesn&amp;rsquo;t require external ressources like ghost does. It further decreases the amount of ressources used on the server.</description>
    </item>
    
    <item>
      <title>Aes Gcm Speedup</title>
      <link>https://www.franziskuskiefer.de/post/aes-gcm-speedup/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/aes-gcm-speedup/</guid>
      <description>AES-GCM is a NIST standardised authenticated encryption algorithm (FIPS 800-38D). Since its standardisation in 2008 its usage increased to a point where it is the prevalent encryption used with TLS. With 85% it is by far the most widely used cipher.
 Firefox 53 TLS cipher telemetry   Unfortunately the AES-GCM implementation used in Firefox (provided by NSS) does not take advantage of full hardware acceleration; it uses a slower software-only implementation on Mac, Linux 32-bit, or any device that doesn&amp;rsquo;t have the AVX, PCLMUL, and AES-NI hardware instructions.</description>
    </item>
    
    <item>
      <title>On Constant Time Division</title>
      <link>https://www.franziskuskiefer.de/post/constant-time-division/</link>
      <pubDate>Wed, 28 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/constant-time-division/</guid>
      <description>Writing constant time code is hard. We all know that. But I&amp;rsquo;m always amazed again on how difficult it is. In preparation for making NSS more constant time I looked into certain CPU instructions that are known to be not constant time. So I wrote a little thing to measure the time (CPU cycles) needed for division.
div rcx ; eax is now a/b The CPU I&amp;rsquo;m using in this post is an Intel i7-4790 (haswell).</description>
    </item>
    
    <item>
      <title>Blind Password Registration for Two-Server Password Authenticated Key Exchange and Secret Sharing Protocols</title>
      <link>https://www.franziskuskiefer.de/publications/2bpr/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/2bpr/</guid>
      <description>Many organisations enforce policies on the length and formation of passwords to encourage selection of strong passwords and protect their multi-user systems. For Two-Server Password Authenticated Key Exchange (2PAKE) and Two-Server Password Authenticated Secret Sharing (2PASS) protocols, where the password chosen by the client is secretly shared between the two servers, the initial remote registration of policy-compliant passwords represents a major problem because none of the servers is supposed to know the password in clear.</description>
    </item>
    
    <item>
      <title>Universally Composable Two-Server PAKE</title>
      <link>https://www.franziskuskiefer.de/publications/uc2pake/</link>
      <pubDate>Thu, 26 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/uc2pake/</guid>
      <description>Two-Server Password Authenticated Key Exchange (2PAKE) protocols apply secret shar-ing techniques to achieve protection against server-compromise attacks. 2PAKE protocols eliminate the need for password hashing and remain secure as long as one of the servers remains honest. This concept has also been explored in connection with two-server password authenticated secret sharing (2PASS) protocols for which game-based and universally composable versions have been proposed. In contrast, universally composable PAKE protocols exist currently only in the single-server scenario and all proposed 2PAKE protocols use game-based security deÔ¨Ånitions.</description>
    </item>
    
    <item>
      <title>NSS Static Analysis</title>
      <link>https://www.franziskuskiefer.de/post/nss-static-analysis/</link>
      <pubDate>Wed, 25 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/nss-static-analysis/</guid>
      <description>When I started working on NSS 7 months ago one of the tasks I was asked to do was to work through the related Coverity issues. This post summarises some learnings from this as we&amp;rsquo;ve since come a long way since over the last months.
Static analysis plays a crucial part in locating vulnerabilities and bugs during development. For NSS we currently use multiple static analysis tools. While scan-build as well as infer are great applications to find bugs, they require a lot of manual management.</description>
    </item>
    
    <item>
      <title>Blind Password Registration for Verifier-based PAKE</title>
      <link>https://www.franziskuskiefer.de/publications/bpr/</link>
      <pubDate>Sun, 01 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/bpr/</guid>
      <description>We propose Blind Password Registration (BPR), a new class of cryptographic protocols that is instrumental for secure registration of client passwords at remote servers with additional protection against unwitting password disclosures on the server side that may occur due to the lack of the state-of-the-art password protection mechanisms implemented by the server or due to common server-compromise attacks. The dictionary attack resistance property of BPR protocols guarantees that the only information available to the server during and after the execution of the protocol cannot be used to reveal the client password without performing an offline dictionary attack on a password verifier (e.</description>
    </item>
    
    <item>
      <title>RawGit Firefox Extension</title>
      <link>https://www.franziskuskiefer.de/post/raw-github/</link>
      <pubDate>Sat, 02 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/raw-github/</guid>
      <description>~This extension doesn&amp;rsquo;t work from Firefox 57 on. I might update it when I find time.~
Ever wanted to view HTML pages directly from GitHub? Me too. Unfortunately the Raw button doesn&amp;rsquo;t render the HTML but only displays the source code. There are a bunch of Chrome extensions that add a button to open file from Github at rawgit directly, but none for Firefox. So I wrote one. It&amp;rsquo;s still an early version and more of a hack than a real extension, but it works (mostly).</description>
    </item>
    
    <item>
      <title>Secure Set-based Policy Checking and Its Application to Password Registration</title>
      <link>https://www.franziskuskiefer.de/publications/spc/</link>
      <pubDate>Thu, 10 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/spc/</guid>
      <description>Policies are the corner stones of today&amp;rsquo;s computer systems. They define secure states and safe operations. A common problem with policies is that their enforcement is often in conflict with user privacy. In order to check the satisfiability of a policy, a server usually needs to collect from a client some information which may be private. In this work we introduce the notion of secure set-based policy checking (SPC) that allows the server to verify policies while preserving the client&amp;rsquo;s privacy.</description>
    </item>
    
    <item>
      <title>Oblivious PAKE: Efficient Handling of Password Trials</title>
      <link>https://www.franziskuskiefer.de/publications/opake/</link>
      <pubDate>Thu, 27 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/opake/</guid>
      <description>In this work we introduce the notion of Oblivious Password based Authenticated Key Exchange (O-PAKE) and a general compiler to transform a large class of PAKE into O-PAKE protocols. O-PAKE allows a client that shares one password with a server to use a set of passwords within one PAKE session. It succeeds if and only if one of those input passwords matches the one stored on the server side. The term oblivious is used to emphasize that no information about any password, input by the client, is made available to the server.</description>
    </item>
    
    <item>
      <title>Submitting through Editorial Manager</title>
      <link>https://www.franziskuskiefer.de/post/editorial-manager/</link>
      <pubDate>Fri, 06 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/editorial-manager/</guid>
      <description>Today I had to submit a paper through the Editorial Manager (used by Springer) for the first time. Needless to say that it&amp;rsquo;s not as easy as it sounds. Therefore here some helpful links for everyone having to do the same. I ended up putting the references in the .tex file as nothing else worked for me.
 http://www.bartneck.de/2010/09/30/submitting-your-latex-manuscript-to-editorial-manager-springer-elsevier/ http://drezha.me.uk/post/22719621060/submitting-a-springerlink-elsvier-journal-using  </description>
    </item>
    
    <item>
      <title>Secure modular password authentication for the web using channel bindings</title>
      <link>https://www.franziskuskiefer.de/publications/smpa/</link>
      <pubDate>Tue, 16 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/smpa/</guid>
      <description>Secure protocols for password-based user authentication are well-studied in the cryptographic literature but have failed to see wide-spread adoption on the Internet; most proposals to date require extensive modifications to the Transport Layer Security (TLS) protocol, making deployment challenging. Recently, a few modular designs have been proposed in which a cryptographically secure password-based mutual authentication protocol is run inside a confidential (but not necessarily authenticated) channel such as TLS; the password protocol is bound to the established channel to prevent active attacks.</description>
    </item>
    
    <item>
      <title>OpenVPN HowTo</title>
      <link>https://www.franziskuskiefer.de/post/openvpn/</link>
      <pubDate>Sun, 12 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/openvpn/</guid>
      <description>OpenPVN is an easy to set-up and use VPN solution that offer TUN/TAP support. In this tutorial I describe how to set-up an OpenVPN connection between a Ubuntu server and an Arch client.
Preparations (Server) First we have to install OpenVPN on the server.
# apt-get install openvpn To see whether TUN/TAP is enabled in the kernel we can check the kernel log grep tun /var/log/kern.log and load it if it doesn&amp;rsquo;t show up modprobe tun.</description>
    </item>
    
    <item>
      <title>Snort, Barnyard2 &amp; Snorby</title>
      <link>https://www.franziskuskiefer.de/post/snort/</link>
      <pubDate>Sun, 05 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/snort/</guid>
      <description>This post is work in progress but I never got around to finishing it. Sorry
After a first failed attempt to install Snorby on an Arch Linux server (Snorby requires Ruby 1.9.x, Arch uses 2.x and I&amp;rsquo;m not willing to use the AUR version for this) I&amp;rsquo;m doing this on a Ubuntu 14.04 Server.
Snort Before installing Snorby we have to install snort itself. This can be done with sudo apt-get install snort.</description>
    </item>
    
    <item>
      <title>The curious case of pgflibraryfadings</title>
      <link>https://www.franziskuskiefer.de/post/pgflibraryfadings/</link>
      <pubDate>Mon, 01 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/pgflibraryfadings/</guid>
      <description>Over the last year I was battling a strange error of reverse synctex search with evince and several latex editors. Everything works perfect with synctex unless I want to do a reverse search (click in the pdf docutment and get the according tex position) on the first page. Instead of getting the correct position my latex editor always opens the file pgflibraryfadings.code.tex. While I finally found the cause of the problem, I have no idea how to solve it.</description>
    </item>
    
    <item>
      <title>Display &amp; Inline Math</title>
      <link>https://www.franziskuskiefer.de/post/displaymath/</link>
      <pubDate>Sun, 17 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/post/displaymath/</guid>
      <description>Another day in latex wonderland &amp;hellip; Today I was writing an equation in an aligned environment using sum and those fancy things. Unfortunately aligned is a display math environment such that the limits of sum are displayed above and below, which was really not suitable in my case. So how do I display inline-math style in a display math environment?
Let&amp;rsquo;s say we have an equation environment with an equation</description>
    </item>
    
    <item>
      <title>Zero-Knowledge Password Policy Checks and Verifier-Based PAKE</title>
      <link>https://www.franziskuskiefer.de/publications/zkppc/</link>
      <pubDate>Mon, 07 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/zkppc/</guid>
      <description>Zero-Knowledge Password Policy Checks (ZKPPC), introduced in this work, enable blind registration of client passwords at remote servers, i.e., client passwords are never transmitted to the servers. This eliminates the need for trusting servers to securely process and store client passwords. A ZKPPC protocol, executed as part of the registration procedure, allows clients to further prove compliance of chosen passwords with respect to password policies defined by the servers. The main benefit of ZKPPC-based password registration is that it guarantees that registered passwords never appear in clear on the server side.</description>
    </item>
    
    <item>
      <title>Distributed Smooth Projective Hashing and its Application to Two-Server Password Authenticated Key Exchange</title>
      <link>https://www.franziskuskiefer.de/publications/dsphf/</link>
      <pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/dsphf/</guid>
      <description>Smooth projective hash functions have been used as building block for various cryptographic applications, in particular for password-based authentication. In this work we propose the extended concept of distributed smooth projective hash functions where the computation of the hash value is distributed across $n$ parties and show how to instantiate the underlying approach for languages consisting of Cramer-Shoup ciphertexts. As an application of distributed smooth projective hashing we build a new framework for the design of two-server password authenticated key exchange protocols, which we believe can help to &amp;ldquo;explain&amp;rdquo; the design of earlier two-server password authenticated key exchange protocols.</description>
    </item>
    
    <item>
      <title>Pseudorandom Signatures</title>
      <link>https://www.franziskuskiefer.de/publications/prs/</link>
      <pubDate>Wed, 08 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/prs/</guid>
      <description>We develop a three-level hierarchy of privacy notions for (unforgeable) digital signature schemes. We first prove mutual independence of existing notions of anonymity and confidentiality, and then show that these are implied by higher privacy goals. The top notion in our hierarchy is pseudorandomness signatures with this property hide the entire information about the signing process and cannot be recognized as signatures when transmitted over a public network. This implies very strong unlinkability guarantees across different signers and even different signing algorithms, and gives rise to new forms of private public-key authentication.</description>
    </item>
    
    <item>
      <title>Revocation and Non-repudiation: When the First Destroys the Latter</title>
      <link>https://www.franziskuskiefer.de/publications/europki/</link>
      <pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/europki/</guid>
      <description>Electronic signatures replace handwritten signatures in electronic processes. In this context, non-repudiation is one of the most desired properties yet in practice it cannot be provided by the signature schemes themselves. Therefore, additional mechanisms in the underlying public key infrastructure are required. In this work, we present a formal treatment of that issue. We extend the formal model for public key infrastructures by Maurer introducing transitions to make it dynamic. We use the extended model to evaluate the relationship between non-repudiation and revocation and prove that backdated revocation always destroys the non-repudiation property.</description>
    </item>
    
    <item>
      <title>Group Signatures: Privacy-Preserving Authentication Methods</title>
      <link>https://www.franziskuskiefer.de/publications/gs/</link>
      <pubDate>Thu, 23 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/gs/</guid>
      <description>Group signatures are cryptographic privacy-preserving authentication mechanisms. Potential signers are formed into a group, which is managed by a usually centralized authority (group manager). Each group member being in possession of a (valid) membership certificate can sign documents on behalf of the whole group. In addition to various forms of unforgeability the distinguished privacy property of group signatures is that they do not leak any information about the actual signer, except for the validity of the signer&amp;rsquo;s membership in the group.</description>
    </item>
    
    <item>
      <title>Practical Security in E-Mail Applications</title>
      <link>https://www.franziskuskiefer.de/publications/bird/</link>
      <pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/bird/</guid>
      <description>This paper deals with practicability issues of encrypted e-mails. A quick survey on the status quo indicates that popular e-mail clients lack substantial practicability qualities, for example searching in encrypted e-mails. Other approaches such as De-Mail provide solutions, but offer transport encryption only. We present and discuss a number of improvements to the practicability of e-mail encryption. These enable efficient searching in encrypted e-mails as well as subject encryption and the use of cryptographic functions in calendar applications.</description>
    </item>
    
    <item>
      <title>An efficient mobile PACE implementation</title>
      <link>https://www.franziskuskiefer.de/publications/pace/</link>
      <pubDate>Tue, 01 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://www.franziskuskiefer.de/publications/pace/</guid>
      <description>Many future electronic identity cards will be equipped with a contact-less interface. Analysts expect that a significant proportion of future mobile phones support Near Field Communication (NFC) technology. Thus, it is a reasonable approach to use the cell phone as mobile smart card terminal, which in particular supports the Password Authenticated Connection Establishment (PACE) protocol to ensure user consent and to protect the wireless interface between the mobile phone and the smart card.</description>
    </item>
    
  </channel>
</rss>
